<!DOCTYPE html>
<html lang="en">
<head>
    <title>WebXR Video with Depth and GPGPU Curl Noise</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <style>
        body {
            margin: 0;
            background-color: #000;
            color: #fff;
            font-family: Monospace;
            font-size: 13px;
            text-align: center;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 10px;
            width: 100%;
            text-align: center;
            z-index: 100;
            color: white;
            text-shadow: 0 0 5px #000;
            pointer-events: none;
        }
        #webgl-canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }
        #video {
            display: none;
        }
        .webxr-button {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            padding: 10px 20px;
            background-color: #0080ff;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
            z-index: 1000;
        }
    </style>
    <style type="text/css">
        .dg ul{list-style:none;margin:0;padding:0;width:100%;clear:both}.dg.ac{position:fixed;top:0;left:0;right:0;height:0;z-index:0}.dg:not(.ac) .main{overflow:hidden}.dg.main{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear}.dg.main.taller-than-window{overflow-y:auto}.dg.main.taller-than-window .close-button{opacity:1;margin-top:-1px;border-top:1px solid #2c2c2c}.dg.main ul.closed .close-button{opacity:1 !important}.dg.main:hover .close-button,.dg.main .close-button.drag{opacity:1}.dg.main .close-button{-webkit-transition:opacity .1s linear;-o-transition:opacity .1s linear;-moz-transition:opacity .1s linear;transition:opacity .1s linear;border:0;line-height:19px;height:20px;cursor:pointer;text-align:center;background-color:#000}.dg.main .close-button.close-top{position:relative}.dg.main .close-button.close-bottom{position:absolute}.dg.main .close-button:hover{background-color:#111}.dg.a{float:right;margin-right:15px;overflow-y:visible}.dg.a.has-save>ul.close-top{margin-top:0}.dg.a.has-save>ul.close-bottom{margin-top:27px}.dg.a.has-save>ul.closed{margin-top:0}.dg.a .save-row{top:0;z-index:1002}.dg.a .save-row.close-top{position:relative}.dg.a .save-row.close-bottom{position:fixed}.dg li{-webkit-transition:height .1s ease-out;-o-transition:height .1s ease-out;-moz-transition:height .1s ease-out;transition:height .1s ease-out;-webkit-transition:overflow .1s linear;-o-transition:overflow .1s linear;-moz-transition:overflow .1s linear;transition:overflow .1s linear}.dg li:not(.folder){cursor:auto;height:27px;line-height:27px;padding:0 4px 0 5px}.dg li.folder{padding:0;border-left:4px solid rgba(0,0,0,0)}.dg li.title{cursor:pointer;margin-left:-4px}.dg .closed li:not(.title),.dg .closed ul li,.dg .closed ul li>*{height:0;overflow:hidden;border:0}.dg .cr{clear:both;padding-left:3px;height:27px;overflow:hidden}.dg .property-name{cursor:default;float:left;clear:left;width:40%;overflow:hidden;text-overflow:ellipsis}.dg .c{float:left;width:60%;position:relative}.dg .c input[type=text]{border:0;margin-top:4px;padding:3px;width:100%;float:right}.dg .has-slider input[type=text]{width:30%;margin-left:0}.dg .slider{float:left;width:66%;margin-left:-5px;margin-right:0;height:19px;margin-top:4px}.dg .slider-fg{height:100%}.dg .c input[type=checkbox]{margin-top:7px}.dg .c select{margin-top:5px}.dg .cr.function,.dg .cr.function .property-name,.dg .cr.function *,.dg .cr.boolean,.dg .cr.boolean *{cursor:pointer}.dg .cr.color{overflow:visible}.dg .selector{display:none;position:absolute;margin-left:-9px;margin-top:23px;z-index:10}.dg .c:hover .selector,.dg .selector.drag{display:block}.dg li.save-row{padding:0}.dg li.save-row .button{display:inline-block;padding:0px 6px}.dg.dialogue{background-color:#222;width:460px;padding:15px;font-size:13px;line-height:15px}#dg-new-constructor{padding:10px;color:#222;font-family:Monaco, monospace;font-size:10px;border:0;resize:none;box-shadow:inset 1px 1px 1px #888;word-wrap:break-word;margin:12px 0;display:block;width:440px;overflow-y:scroll;height:100px;position:relative}#dg-local-explain{display:none;font-size:11px;line-height:17px;border-radius:3px;background-color:#333;padding:8px;margin-top:10px}#dg-local-explain code{font-size:10px}#dat-gui-save-locally{display:none}.dg{color:#eee;font:11px 'Lucida Grande', sans-serif;text-shadow:0 -1px 0 #111}.dg.main::-webkit-scrollbar{width:5px;background:#1a1a1a}.dg.main::-webkit-scrollbar-corner{height:0;display:none}.dg.main::-webkit-scrollbar-thumb{border-radius:5px;background:#676767}.dg li:not(.folder){background:#1a1a1a;border-bottom:1px solid #2c2c2c}.dg li.save-row{line-height:25px;background:#dad5cb;border:0}.dg li.save-row select{margin-left:5px;width:108px}.dg li.save-row .button{margin-left:5px;margin-top:1px;border-radius:2px;font-size:9px;line-height:7px;padding:4px 4px 5px 4px;background:#c5bdad;color:#fff;text-shadow:0 1px 0 #b0a58f;box-shadow:0 -1px 0 #b0a58f;cursor:pointer}.dg li.save-row .button.gears{background:#c5bdad url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAsAAAANCAYAAAB/9ZQ7AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAQJJREFUeNpiYKAU/P//PwGIC/ApCABiBSAW+I8AClAcgKxQ4T9hoMAEUrxx2QSGN6+egDX+/vWT4e7N82AMYoPAx/evwWoYoSYbACX2s7KxCxzcsezDh3evFoDEBYTEEqycggWAzA9AuUSQQgeYPa9fPv6/YWm/Acx5IPb7ty/fw+QZblw67vDs8R0YHyQhgObx+yAJkBqmG5dPPDh1aPOGR/eugW0G4vlIoTIfyFcA+QekhhHJhPdQxbiAIguMBTQZrPD7108M6roWYDFQiIAAv6Aow/1bFwXgis+f2LUAynwoIaNcz8XNx3Dl7MEJUDGQpx9gtQ8YCueB+D26OECAAQDadt7e46D42QAAAABJRU5ErkJggg==) 2px 1px no-repeat;height:7px;width:8px}.dg li.save-row .button:hover{background-color:#bab19e;box-shadow:0 -1px 0 #b0a58f}.dg li.folder{border-bottom:0}.dg li.title{padding-left:16px;background:#000 url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlI+hKgFxoCgAOw==) 6px 10px no-repeat;cursor:pointer;border-bottom:1px solid rgba(255,255,255,0.2)}.dg .closed li.title{background-image:url(data:image/gif;base64,R0lGODlhBQAFAJEAAP////Pz8////////yH5BAEAAAIALAAAAAAFAAUAAAIIlGIWqMCbWAEAOw==)}.dg .cr.boolean{border-left:3px solid #806787}.dg .cr.color{border-left:3px solid}.dg .cr.function{border-left:3px solid #e61d5f}.dg .cr.number{border-left:3px solid #2FA1D6}.dg .cr.number input[type=text]{color:#2FA1D6}.dg .cr.string{border-left:3px solid #1ed36f}.dg .cr.string input[type=text]{color:#1ed36f}.dg .cr.function:hover,.dg .cr.boolean:hover{background:#111}.dg .c input[type=text]{background:#303030;outline:none}.dg .c input[type=text]:hover{background:#3c3c3c}.dg .c input[type=text]:focus{background:#494949;color:#fff}.dg .c .slider{background:#303030;cursor:ew-resize}.dg .c .slider-fg{background:#2FA1D6;max-width:100%}.dg .c .slider:hover{background:#3c3c3c}.dg .c .slider:hover .slider-fg{background:#44abda}
    </style>
</head>
<body>
    <div id="info">
        WebXR Video with Depth and GPGPU Curl Noise - Use WebXR device to view. On desktop: Drag to rotate, right-click to translate, scroll to zoom.
    </div>
    <video id="video" loop crossorigin="anonymous" muted playsinline src="beach.mp4"></video>
    <div id="container"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.167.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.167.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/dat-gui/0.7.7/dat.gui.min.js"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { XRButton } from 'three/addons/webxr/XRButton.js';
        import { GPUComputationRenderer } from 'three/addons/misc/GPUComputationRenderer.js';
        import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
        import { OculusHandModel } from 'three/addons/webxr/OculusHandModel.js';

        let scene, camera, renderer, controls, video, videoTexture, particles, particleMaterial, gpgpuParticles, gpgpuParticleMaterial, gpuCompute, positionVariable;
        let hand1, hand2, leftHand, rightHand, handsLeftRightDefined = false, handRenderingSet = false;
        let leftHandPosition = new THREE.Vector3(0, 0, 0);
        let rightHandIndexFingerPosition = new THREE.Vector3(1000, 1000, 1000);
        let mainScene, originalMainScenePosition, originalMainSceneScale = 1;
        let handFaceUp = false, handFaceUpTimeSince = 0;
        let handMaterialInterval = null;
        const leftHandInteractionPosition = new THREE.Vector3();

        const GRID_WIDTH = 512;
        const GRID_HEIGHT = 256;
        const VISUAL_RESOLUTION_X = 1024;
        const VISUAL_RESOLUTION_Y = 512;

        const params = {
            particleSize: 2000.0,
            focalLengthX: 1100.0,
            focalLengthY: 1100.0,
            minZ: -1000.0,
            maxZ: -120.0,
            reverseDepthMap: false,
            farOffAmount: 0.0,
            showGpgpuParticles: true,
            gpgpuLifeDuration: 5.0,
            gpgpuSpeed: 40.0,
            gpgpuOpacity: 0.25,
            curlAmplitude: 40.0,
            curlFrequency: 0.005,
            additiveBlending: true,
            interactionForce: -220.0,
            interactionRadius: 0.5
        };

        function setHandRendering() {
            console.log("Setting hand material");
            let t = new THREE.TextureLoader().load("https://cdn.jsdelivr.net/npm/three@0.167.0/examples/textures/uv_grid_opengl.jpg");
            t.flipY = false;
            let material = new THREE.MeshPhongMaterial({
                map: t,
                transparent: true,
                opacity: 0.25
            });
            hand1.children[0].children[0].children[0].material = material;
            hand2.children[0].children[0].children[0].material = material;
            handRenderingSet = true;
        }

        function getHandLeftRight() {
            if (
                hand1.children[0] &&
                hand1.children[0].children &&
                hand1.children[0].children.length > 0 &&
                hand2.children[0] &&
                hand2.children[0].children &&
                hand2.children[0].children.length > 0
            ) {
                if (hand1.children[0].xrInputSource.handedness === "left") {
                    leftHand = hand1;
                    rightHand = hand2;
                } else {
                    leftHand = hand2;
                    rightHand = hand1;
                }
                handsLeftRightDefined = true;
                setHandRendering();
            }
        }

        function setObjectToHand() {
            let desideredScaleInHand = 0.05;
            if (handsLeftRightDefined) {
                let p = rightHand.joints["middle-finger-phalanx-proximal"];
                leftHandPosition = p.getWorldPosition(new THREE.Vector3());
                rightHandIndexFingerPosition = rightHand.joints["index-finger-tip"].getWorldPosition(new THREE.Vector3());

                let q = rightHand.children[1].quaternion;
                let angle = new THREE.Euler().setFromQuaternion(q);

                if (Math.abs(angle.z) < 1.1) {
                    handFaceUp = false;
                    handFaceUpTimeSince = Math.min(handFaceUpTimeSince + 4, 1000);

                    let cp1 = mainScene.position;
                    let position1 = { x: cp1.x, y: cp1.y, z: cp1.z };
                    let target1 = {
                        x: originalMainScenePosition.x,
                        y: originalMainScenePosition.y,
                        z: originalMainScenePosition.z
                    };
                    let targetScale = originalMainSceneScale;

                    let speedGrow = 0.011;

                    mainScene.position.x = position1.x + speedGrow * (target1.x - position1.x);
                    mainScene.position.y = position1.y + speedGrow * (target1.y - position1.y);
                    mainScene.position.z = position1.z + speedGrow * (target1.z - position1.z);

                    mainScene.scale.x = mainScene.scale.x + speedGrow * (targetScale - mainScene.scale.x);
                    mainScene.scale.y = mainScene.scale.y + speedGrow * (targetScale - mainScene.scale.y);
                    mainScene.scale.z = mainScene.scale.z + speedGrow * (targetScale - mainScene.scale.z);

                    const targetMaxZ = -1000.0;
                    const targetFarOff = 0.0;
                    const targetOpacity = 0.0;

                    let currentMaxZ = particleMaterial.uniforms.u_maxZ.value;
                    const newMaxZ = currentMaxZ + speedGrow * (targetMaxZ - currentMaxZ);
                    particleMaterial.uniforms.u_maxZ.value = newMaxZ;
                    positionVariable.material.uniforms.u_maxZ.value = newMaxZ;

                    let currentFarOff = particleMaterial.uniforms.u_farOffAmount.value;
                    const newFarOff = currentFarOff + speedGrow * (targetFarOff - currentFarOff);
                    particleMaterial.uniforms.u_farOffAmount.value = newFarOff;
                    gpgpuParticleMaterial.uniforms.u_farOffAmount.value = newFarOff;

                    let currentOpacity = gpgpuParticleMaterial.uniforms.u_opacity.value;
                    const newOpacity = currentOpacity + speedGrow * (targetOpacity - currentOpacity);
                    gpgpuParticleMaterial.uniforms.u_opacity.value = newOpacity;
                } else {
                    handFaceUp = true;
                    handFaceUpTimeSince = Math.max(handFaceUpTimeSince - 4, 0);

                    let cp = mainScene.position;
                    let position = { x: cp.x, y: cp.y, z: cp.z };
                    let target = {
                        x: leftHandPosition.x,
                        y: leftHandPosition.y + 0.1,
                        z: leftHandPosition.z + 0.2
                    };

                    let speedBack = 0.08;

                    mainScene.position.x = position.x + speedBack * (target.x - position.x);
                    mainScene.position.y = position.y + speedBack * (target.y - position.y);
                    mainScene.position.z = position.z + speedBack * (target.z - position.z);

                    mainScene.scale.x = mainScene.scale.x + speedBack * (desideredScaleInHand - mainScene.scale.x);
                    mainScene.scale.y = mainScene.scale.y + speedBack * (desideredScaleInHand - mainScene.scale.y);
                    mainScene.scale.z = mainScene.scale.z + speedBack * (desideredScaleInHand - mainScene.scale.z);

                    const targetMaxZ = -478.0;
                    const targetFarOff = 0.72;
                    const targetOpacity = 0.33;

                    let currentMaxZ = particleMaterial.uniforms.u_maxZ.value;
                    const newMaxZ = currentMaxZ + speedBack * (targetMaxZ - currentMaxZ);
                    particleMaterial.uniforms.u_maxZ.value = newMaxZ;
                    positionVariable.material.uniforms.u_maxZ.value = newMaxZ;

                    let currentFarOff = particleMaterial.uniforms.u_farOffAmount.value;
                    const newFarOff = currentFarOff + speedBack * (targetFarOff - currentFarOff);
                    particleMaterial.uniforms.u_farOffAmount.value = newFarOff;
                    gpgpuParticleMaterial.uniforms.u_farOffAmount.value = newFarOff;

                    let currentOpacity = gpgpuParticleMaterial.uniforms.u_opacity.value;
                    const newOpacity = currentOpacity + speedBack * (targetOpacity - currentOpacity);
                    gpgpuParticleMaterial.uniforms.u_opacity.value = newOpacity;
                }
            }
        }

        function init() {
            const container = document.getElementById('container');
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            camera.position.z = 210;

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.setClearColor(0x000000, 1);
            renderer.xr.enabled = true;
            container.appendChild(renderer.domElement);

            document.body.appendChild(XRButton.createButton(renderer, { requiredFeatures: ['hand-tracking'] }));

            // Hand-tracking setup
            const controller1 = renderer.xr.getController(0);
            scene.add(controller1);
            const controller2 = renderer.xr.getController(1);
            scene.add(controller2);

            const controllerModelFactory = new XRControllerModelFactory();

            const controllerGrip1 = renderer.xr.getControllerGrip(0);
            controllerGrip1.add(controllerModelFactory.createControllerModel(controllerGrip1));
            scene.add(controllerGrip1);

            hand1 = renderer.xr.getHand(0);
            hand1.add(new OculusHandModel(hand1));
            scene.add(hand1);

            const controllerGrip2 = renderer.xr.getControllerGrip(1);
            controllerGrip2.add(controllerModelFactory.createControllerModel(controllerGrip2));
            scene.add(controllerGrip2);

            hand2 = renderer.xr.getHand(1);
            hand2.add(new OculusHandModel(hand2));
            scene.add(hand2);

            // Video setup
            video = document.getElementById('video');
            video.play().catch(e => console.error('Video auto-play failed:', e));
            videoTexture = new THREE.VideoTexture(video);
            videoTexture.minFilter = THREE.NearestFilter;
            videoTexture.magFilter = THREE.NearestFilter;
            videoTexture.format = THREE.RGBAFormat;

            // Main hologram particle geometry
            const geometry = createParticleGeometry(GRID_WIDTH, GRID_HEIGHT);

            // Main hologram particle material
            particleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    u_videoTexture: { value: videoTexture },
                    u_size: { value: params.particleSize },
                    u_focalLengthX: { value: params.focalLengthX },
                    u_focalLengthY: { value: params.focalLengthY },
                    u_minZ: { value: params.minZ },
                    u_maxZ: { value: params.maxZ },
                    u_resolution: { value: new THREE.Vector2(VISUAL_RESOLUTION_X, VISUAL_RESOLUTION_Y) },
                    u_depthMapResolution: { value: new THREE.Vector2(VISUAL_RESOLUTION_X, VISUAL_RESOLUTION_Y / 2) },
                    u_reverseDepth: { value: params.reverseDepthMap ? 1.0 : 0.0 },
                    u_farOffAmount: { value: params.farOffAmount }
                },
                vertexShader: `
                    uniform sampler2D u_videoTexture;
                    uniform float u_size;
                    uniform float u_focalLengthX;
                    uniform float u_focalLengthY;
                    uniform float u_minZ;
                    uniform float u_maxZ;
                    uniform vec2 u_resolution;
                    uniform vec2 u_depthMapResolution;
                    uniform float u_reverseDepth;

                    varying vec2 vOriginalUv;
                    varying float vDepth;

                    void main() {
                        vec2 gridUv = position.xy;
                        vOriginalUv = gridUv;
                        vec2 depthTextureUv = vec2(gridUv.x, gridUv.y * 0.5);
                        vec2 depthTexelSize = 1. / u_depthMapResolution;
                        vec2 pixelCoord = depthTextureUv * u_depthMapResolution;
                        vec2 fractCoord = fract(pixelCoord);
                        vec2 basePixel = floor(pixelCoord);
                        vec2 uv00 = (basePixel + vec2(0.5, 0.5)) * depthTexelSize;
                        vec2 uv10 = (basePixel + vec2(1.5, 0.5)) * depthTexelSize;
                        vec2 uv01 = (basePixel + vec2(0.5, 1.5)) * depthTexelSize;
                        vec2 uv11 = (basePixel + vec2(1.5, 1.5)) * depthTexelSize;
                        float d00 = texture2D(u_videoTexture, uv00).r;
                        float d10 = texture2D(u_videoTexture, uv10).r;
                        float d01 = texture2D(u_videoTexture, uv01).r;
                        float d11 = texture2D(u_videoTexture, uv11).r;
                        float interp0 = mix(d00, d10, fractCoord.x);
                        float interp1 = mix(d01, d11, fractCoord.y);
                        float depth = mix(interp0, interp1, fractCoord.y);
                        depth = clamp(depth, 0.0, 1.0);
                        vDepth = depth;
                        if (u_reverseDepth > 0.5) {
                            depth = 1.0 - depth;
                        }
                        float x_pixel = (1.0 - gridUv.x) * u_resolution.x - u_resolution.x / 2.0;
                        float y_pixel = (1.0 - gridUv.y) * u_resolution.y - u_resolution.y / 2.0;
                        float z_world = mix(u_minZ, u_maxZ, depth);
                        vec3 particlePosition;
                        particlePosition.x = (x_pixel * z_world) / u_focalLengthX;
                        particlePosition.y = (y_pixel * z_world) / u_focalLengthY;
                        particlePosition.z = z_world;
                        vec4 modelViewPosition = modelViewMatrix * vec4(particlePosition, 1.0);
                        gl_Position = projectionMatrix * modelViewPosition;
                        float objectScale = length(vec3(modelViewMatrix[0]));
                        gl_PointSize = u_size * objectScale * (1.0 / -modelViewPosition.z);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D u_videoTexture;
                    varying vec2 vOriginalUv;
                    varying float vDepth;
                    uniform float u_farOffAmount;

                    void main() {
                        if (vOriginalUv.y > 0.994) discard;
                        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {
                            discard;
                        }
                        vec2 colorUv = vec2(vOriginalUv.x, vOriginalUv.y * 0.5 + 0.5);
                        vec4 color = texture2D(u_videoTexture, colorUv);
                        if (color.a < 0.1) discard;
                        float farFadeOpacity = u_farOffAmount > 0.001 ? smoothstep(0.0, u_farOffAmount, vDepth) : 1.0;
                        color.a *= farFadeOpacity * 0.65;
                        if (color.a < 0.1) discard;
                        gl_FragColor = color;
                    }
                `,
                transparent: true
            });

            particles = new THREE.Points(geometry, particleMaterial);
            particles.frustumCulled = false;

            // Initialize GPGPU particles
            initGpgpuParticles();

            // Group particles in mainScene for hand interaction
            mainScene = new THREE.Object3D();
            mainScene.add(particles);
            mainScene.add(gpgpuParticles);
            originalMainScenePosition = mainScene.position.clone();
            scene.add(mainScene);

            // GUI setup
            const gui = new dat.GUI();
            gui.add(params, 'particleSize', 2, 4000.0).onChange(value => {
                particleMaterial.uniforms.u_size.value = value;
                gpgpuParticleMaterial.uniforms.u_size.value = value;
            });
            gui.add(params, 'focalLengthX', 1.0, 2000.0).onChange(value => {
                particleMaterial.uniforms.u_focalLengthX.value = value;
                positionVariable.material.uniforms.u_focalLengthX.value = value;
            });
            gui.add(params, 'focalLengthY', 1.0, 2000.0).onChange(value => {
                particleMaterial.uniforms.u_focalLengthY.value = value;
                positionVariable.material.uniforms.u_focalLengthY.value = value;
            });
            gui.add(params, 'minZ', -1000.0, 0.0).onChange(value => {
                particleMaterial.uniforms.u_minZ.value = value;
                positionVariable.material.uniforms.u_minZ.value = value;
            });
            gui.add(params, 'maxZ', -2000.0, -10.0).onChange(value => {
                particleMaterial.uniforms.u_maxZ.value = value;
                positionVariable.material.uniforms.u_maxZ.value = value;
            });
            gui.add(params, 'reverseDepthMap').name('Reverse Depth Map').onChange(value => {
                const val = value ? 1.0 : 0.0;
                particleMaterial.uniforms.u_reverseDepth.value = val;
                positionVariable.material.uniforms.u_reverseDepth.value = val;
            });
            gui.add(params, 'farOffAmount', 0, 1.0).name('Far Off Filter').onChange(value => {
                particleMaterial.uniforms.u_farOffAmount.value = value;
                gpgpuParticleMaterial.uniforms.u_farOffAmount.value = value;
            });

            const fxFolder = gui.addFolder('FX Particle Controls');
            fxFolder.add(params, 'showGpgpuParticles').name('Show FX Particles').onChange(value => {
                gpgpuParticles.visible = value;
            });
            fxFolder.add(params, 'gpgpuLifeDuration', 1.0, 10.0).name('Life Duration').onChange(value => {
                positionVariable.material.uniforms.u_lifeDuration.value = value;
            });
            fxFolder.add(params, 'gpgpuSpeed', -300.0, 300.0).name('Forward Speed').onChange(value => {
                positionVariable.material.uniforms.u_zSpeed.value = value;
            });
            fxFolder.add(params, 'gpgpuOpacity', 0.01, 0.5).name('Overall Opacity').onChange(value => {
                gpgpuParticleMaterial.uniforms.u_opacity.value = value;
            });
            fxFolder.add(params, 'curlAmplitude', 0.0, 200.0).name('Curl Amplitude').onChange(value => {
                positionVariable.material.uniforms.u_curlAmplitude.value = value;
            });
            fxFolder.add(params, 'curlFrequency', 0.001, 0.05).name('Curl Frequency').onChange(value => {
                positionVariable.material.uniforms.u_curlFrequency.value = value;
            });
            fxFolder.add(params, 'interactionForce', -500.0, 500.0).name('Hand Force').onChange(value => {
                positionVariable.material.uniforms.u_interaction_force.value = value;
            });
            fxFolder.add(params, 'interactionRadius', 0.05, 1.0).name('Hand Radius').onChange(value => {
                positionVariable.material.uniforms.u_interaction_radius.value = value;
            });
            fxFolder.add(params, 'additiveBlending').name('Additive Blending').onChange(value => {
                gpgpuParticleMaterial.blending = value ? THREE.AdditiveBlending : THREE.NormalBlending;
                gpgpuParticleMaterial.needsUpdate = true;
            });
            fxFolder.open();

            // Adjust for WebXR
            const originalParams = {
                particleSize: 2000.0,
                scale: new THREE.Vector3(1, 1, 1),
                position: new THREE.Vector3(0, 0, 0)
            };
            const webXRParams = {
                particleSize: 2400.0,
                scale: new THREE.Vector3(0.009, 0.009, 0.009),
                position: new THREE.Vector3(0, 1.4, 0.5)
            };

            renderer.xr.addEventListener('sessionstart', () => {
                particleMaterial.uniforms.u_size.value = webXRParams.particleSize;
                gpgpuParticleMaterial.uniforms.u_size.value = webXRParams.particleSize;
                mainScene.scale.copy(webXRParams.scale);
                mainScene.position.copy(webXRParams.position);
                handMaterialInterval = setInterval(() => {
                    if (handsLeftRightDefined) {
                        console.log("Periodically resetting hand material.");
                        setHandRendering();
                    }
                }, 5000);
            });

            renderer.xr.addEventListener('sessionend', () => {
                particleMaterial.uniforms.u_size.value = originalParams.particleSize;
                gpgpuParticleMaterial.uniforms.u_size.value = originalParams.particleSize;
                mainScene.scale.copy(originalParams.scale);
                mainScene.position.copy(originalParams.position);
                if (handMaterialInterval) {
                    clearInterval(handMaterialInterval);
                    handMaterialInterval = null;
                }
            });

            // Orbit controls for desktop
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            window.addEventListener('resize', onWindowResize);
            renderer.setAnimationLoop(animate);
        }

        function createParticleGeometry(width, height) {
            const NUM_PARTICLES = width * height;
            const geometry = new THREE.BufferGeometry();
            const gridUvs = new Float32Array(NUM_PARTICLES * 3);
            const randoms = new Float32Array(NUM_PARTICLES);
            let pIdx = 0;
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    gridUvs[pIdx * 3 + 0] = x / (width - 1);
                    gridUvs[pIdx * 3 + 1] = y / (height - 1);
                    gridUvs[pIdx * 3 + 2] = 0;
                    randoms[pIdx] = Math.random();
                    pIdx++;
                }
            }
            geometry.setAttribute('position', new THREE.BufferAttribute(gridUvs, 3));
            geometry.setAttribute('a_random', new THREE.BufferAttribute(randoms, 1));
            return geometry;
        }

        function initGpgpuParticles() {
            gpuCompute = new GPUComputationRenderer(GRID_WIDTH, GRID_HEIGHT, renderer);
            if (renderer.capabilities.isWebGL2 === false) {
                gpuCompute.setDataType(THREE.HalfFloatType);
            }

            const dtPosition = gpuCompute.createTexture();
            const p = dtPosition.image.data;
            for (let i = 0; i < p.length; i += 4) {
                p[i + 0] = 0;
                p[i + 1] = 0;
                p[i + 2] = 0;
                p[i + 3] = -1.0;
            }

            positionVariable = gpuCompute.addVariable('texturePosition', gpgpuPositionShader(), dtPosition);
            gpuCompute.setVariableDependencies(positionVariable, [positionVariable]);

            positionVariable.material.uniforms['u_time'] = { value: 0.0 };
            positionVariable.material.uniforms['u_deltaTime'] = { value: 0.0 };
            positionVariable.material.uniforms['u_videoTexture'] = { value: videoTexture };
            positionVariable.material.uniforms['u_focalLengthX'] = { value: params.focalLengthX };
            positionVariable.material.uniforms['u_focalLengthY'] = { value: params.focalLengthY };
            positionVariable.material.uniforms['u_minZ'] = { value: params.minZ };
            positionVariable.material.uniforms['u_maxZ'] = { value: params.maxZ };
            positionVariable.material.uniforms['u_resolution'] = { value: new THREE.Vector2(VISUAL_RESOLUTION_X, VISUAL_RESOLUTION_Y) };
            positionVariable.material.uniforms['u_depthMapResolution'] = { value: new THREE.Vector2(VISUAL_RESOLUTION_X, VISUAL_RESOLUTION_Y / 2) };
            positionVariable.material.uniforms['u_reverseDepth'] = { value: params.reverseDepthMap ? 1.0 : 0.0 };
            positionVariable.material.uniforms['u_lifeDuration'] = { value: params.gpgpuLifeDuration };
            positionVariable.material.uniforms['u_zSpeed'] = { value: params.gpgpuSpeed };
            positionVariable.material.uniforms['u_curlAmplitude'] = { value: params.curlAmplitude };
            positionVariable.material.uniforms['u_curlFrequency'] = { value: params.curlFrequency };
            positionVariable.material.uniforms['u_emitterMatrix'] = { value: new THREE.Matrix4() };
            positionVariable.material.uniforms['u_emitterScale'] = { value: 1.0 };
            positionVariable.material.uniforms['u_forward'] = { value: new THREE.Vector3(0, 0, 1) };
            positionVariable.material.uniforms['u_interaction_point'] = { value: new THREE.Vector3(1000, 1000, 1000) };
            positionVariable.material.uniforms['u_interaction_force'] = { value: params.interactionForce };
            positionVariable.material.uniforms['u_interaction_radius'] = { value: params.interactionRadius };

            const error = gpuCompute.init();
            if (error !== null) {
                console.error(error);
            }

            gpgpuParticleMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    u_positions: { value: null },
                    u_videoTexture: { value: videoTexture },
                    u_size: { value: params.particleSize },
                    u_opacity: { value: params.gpgpuOpacity },
                    u_farOffAmount: { value: params.farOffAmount }
                },
                vertexShader: `
                    uniform sampler2D u_positions;
                    uniform sampler2D u_videoTexture;
                    uniform float u_size;

                    attribute float a_random;
                    varying vec2 vOriginalUv;
                    varying float vLife;
                    varying float vDepth;

                    void main() {
                        vec2 gridUv = position.xy;
                        vOriginalUv = gridUv;

                        vec4 posLife = texture2D(u_positions, gridUv);
                        vec3 worldPosition = posLife.xyz;
                        vLife = posLife.w;

                        vec2 depthTextureUv = vec2(gridUv.x, gridUv.y * 0.5);
                        vDepth = texture2D(u_videoTexture, depthTextureUv).r;

                        vec4 viewPosition = viewMatrix * vec4(worldPosition, 1.0);
                        gl_Position = projectionMatrix * viewPosition;

                        float objectScale = length(vec3(modelMatrix[0]));
                        gl_PointSize = u_size * objectScale * (1.0 / -viewPosition.z);
                    }
                `,
                fragmentShader: `
                    uniform sampler2D u_videoTexture;
                    uniform float u_opacity;
                    uniform float u_farOffAmount;

                    varying vec2 vOriginalUv;
                    varying float vLife;
                    varying float vDepth;

                    void main() {
                        if (length(gl_PointCoord - vec2(0.5, 0.5)) > 0.5) {
                            discard;
                        }

                        vec2 colorUv = vec2(vOriginalUv.x, vOriginalUv.y * 0.5 + 0.5);
                        vec4 color = texture2D(u_videoTexture, colorUv);

                        if (color.a < 0.1) discard;

                        float lifeFade = smoothstep(0.0, 1.5, vLife);
                        float depthFade = u_farOffAmount > 0.001 ? smoothstep(0.0, u_farOffAmount, vDepth) : 1.0;
                        color.a *= lifeFade * depthFade * u_opacity;

                        gl_FragColor = color;
                    }
                `,
                transparent: true,
                blending: params.additiveBlending ? THREE.AdditiveBlending : THREE.NormalBlending,
                depthWrite: false
            });

            gpgpuParticles = new THREE.Points(particles.geometry, gpgpuParticleMaterial);
            gpgpuParticles.frustumCulled = false;
            gpgpuParticles.visible = params.showGpgpuParticles;
        }

        function gpgpuPositionShader() {
            return `
                uniform float u_time;
                uniform float u_deltaTime;
                uniform float u_lifeDuration;
                uniform float u_zSpeed;
                uniform float u_curlAmplitude;
                uniform float u_curlFrequency;
                uniform mat4 u_emitterMatrix;
                uniform float u_emitterScale;
                uniform vec3 u_forward;
                uniform vec3 u_interaction_point;
                uniform float u_interaction_force;
                uniform float u_interaction_radius;
                uniform sampler2D u_videoTexture;
                uniform float u_focalLengthX;
                uniform float u_focalLengthY;
                uniform float u_minZ;
                uniform float u_maxZ;
                uniform vec2 u_resolution;
                uniform vec2 u_depthMapResolution;
                uniform float u_reverseDepth;

                vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
                vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
                vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
                float snoise(vec3 v) {
                    const vec2 C = vec2(1.0/6.0, 1.0/3.0);
                    const vec4 D = vec4(0.0, 0.5, 1.0, 2.0);
                    vec3 i  = floor(v + dot(v, C.yyy));
                    vec3 x0 = v - i + dot(i, C.xxx);
                    vec3 g = step(x0.yzx, x0.xyz);
                    vec3 l = 1.0 - g;
                    vec3 i1 = min(g.xyz, l.zxy);
                    vec3 i2 = max(g.xyz, l.zxy);
                    vec3 x1 = x0 - i1 + C.xxx;
                    vec3 x2 = x0 - i2 + C.yyy;
                    vec3 x3 = x0 - D.yyy;
                    i = mod289(i);
                    vec4 p = permute(permute(permute(i.z + vec4(0.0, i1.z, i2.z, 1.0)) + i.y + vec4(0.0, i1.y, i2.y, 1.0)) + i.x + vec4(0.0, i1.x, i2.x, 1.0));
                    float n_ = 0.142857142857;
                    vec3 ns = n_ * D.wyz - D.xzx;
                    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
                    vec4 x_ = floor(j * ns.z);
                    vec4 y_ = floor(j - 7.0 * x_);
                    vec4 x = x_ * ns.x + ns.yyyy;
                    vec4 y = y_ * ns.x + ns.yyyy;
                    vec4 h = 1.0 - abs(x) - abs(y);
                    vec4 b0 = vec4(x.xy, y.xy);
                    vec4 b1 = vec4(x.zw, y.zw);
                    vec4 s0 = floor(b0)*2.0 + 1.0;
                    vec4 s1 = floor(b1)*2.0 + 1.0;
                    vec4 sh = -step(h, vec4(0.0));
                    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy;
                    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww;
                    vec3 p0 = vec3(a0.xy,h.x);
                    vec3 p1 = vec3(a0.zw,h.y);
                    vec3 p2 = vec3(a1.xy,h.z);
                    vec3 p3 = vec3(a1.zw,h.w);
                    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2,p2), dot(p3,p3)));
                    p0 *= norm.x; p1 *= norm.y; p2 *= norm.z; p3 *= norm.w;
                    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
                    m = m * m;
                    return 42.0 * dot(m*m, vec4(dot(p0,x0), dot(p1,x1), dot(p2,x2), dot(p3,x3)));
                }

                vec3 curlNoise(vec3 p) {
                    const float e = 0.1;
                    float n1, n2, n3, n4;
                    n1 = snoise(vec3(p.x, p.y + e, p.z)); n2 = snoise(vec3(p.x, p.y - e, p.z));
                    n3 = snoise(vec3(p.x, p.y, p.z + e)); n4 = snoise(vec3(p.x, p.y, p.z - e));
                    float cx = (n1 - n2) - (n3 - n4);
                    n1 = snoise(vec3(p.x, p.y, p.z + e)); n2 = snoise(vec3(p.x, p.y, p.z - e));
                    n3 = snoise(vec3(p.x + e, p.y, p.z)); n4 = snoise(vec3(p.x - e, p.y, p.z));
                    float cy = (n1 - n2) - (n3 - n4);
                    n1 = snoise(vec3(p.x + e, p.y, p.z)); n2 = snoise(vec3(p.x - e, p.y, p.z));
                    n3 = snoise(vec3(p.x, p.y + e, p.z)); n4 = snoise(vec3(p.x, p.y - e, p.z));
                    float cz = (n1 - n2) - (n3 - n4);
                    return vec3(cx, cy, cz);
                }

                float rand(vec2 co) { return fract(sin(dot(co.xy, vec2(12.9898,78.233))) * 43758.5453); }

                void main() {
                    vec2 uv = gl_FragCoord.xy / resolution.xy;
                    vec4 posLife = texture2D(texturePosition, uv);
                    vec3 pos = posLife.xyz;
                    float life = posLife.w;

                    life -= u_deltaTime;

                    if (life < 0.0) {
                        vec2 gridUv = uv;
                        vec2 depthTextureUv = vec2(gridUv.x, gridUv.y * 0.5);
                        float depth = texture2D(u_videoTexture, depthTextureUv).r;
                        if (u_reverseDepth > 0.5) { depth = 1.0 - depth; }
                        float x_pixel = (1.0 - gridUv.x) * u_resolution.x - u_resolution.x / 2.0;
                        float y_pixel = (1.0 - gridUv.y) * u_resolution.y - u_resolution.y / 2.0;
                        float z_world = mix(u_minZ, u_maxZ, depth);
                        vec3 localPos;
                        localPos.x = (x_pixel * z_world) / u_focalLengthX;
                        localPos.y = (y_pixel * z_world) / u_focalLengthY;
                        localPos.z = z_world;
                        pos = (u_emitterMatrix * vec4(localPos, 1.0)).xyz;
                        life = u_lifeDuration + u_lifeDuration * (rand(uv + u_time) * 2.0 - 1.0) * 0.5;
                    } else {
                        pos += u_forward * u_zSpeed * u_emitterScale * u_deltaTime;
                        vec3 noise_coord = pos / u_emitterScale;
                        vec3 turbulence = curlNoise(noise_coord * u_curlFrequency);
                        pos += turbulence * u_curlAmplitude * u_emitterScale * u_deltaTime;

                        vec3 toHand = pos - u_interaction_point;
                        float distToHand = length(toHand);
                        if (distToHand < u_interaction_radius && distToHand > 0.0) {
                            float forceFalloff = 1.0 - (distToHand / u_interaction_radius);
                            forceFalloff = pow(forceFalloff, 2.0);
                            vec3 forceDirection = normalize(toHand);
                            pos += forceDirection * u_interaction_force * forceFalloff * u_emitterScale * u_deltaTime;
                        }
                    }

                    gl_FragColor = vec4(pos, life);
                }
            `;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        const clock = new THREE.Clock();
        let lastTime = 0;
        const worldPos = new THREE.Vector3();
        const worldQuat = new THREE.Quaternion();
        const worldScale = new THREE.Vector3();
        const forwardVector = new THREE.Vector3();

        function animate() {
            const elapsedTime = clock.getElapsedTime();
            const deltaTime = elapsedTime - lastTime;
            lastTime = elapsedTime;

            controls.update();

            if (gpuCompute) {
                gpgpuParticles.updateMatrixWorld();
                const matrix = gpgpuParticles.matrixWorld;
                matrix.decompose(worldPos, worldQuat, worldScale);
                forwardVector.set(0, 0, 1).applyQuaternion(worldQuat);

                positionVariable.material.uniforms.u_emitterMatrix.value.copy(matrix);
                positionVariable.material.uniforms.u_emitterScale.value = worldScale.x;
                positionVariable.material.uniforms.u_forward.value.copy(forwardVector);
                positionVariable.material.uniforms.u_time.value = elapsedTime;
                positionVariable.material.uniforms.u_deltaTime.value = deltaTime;

                gpuCompute.compute();

                gpgpuParticleMaterial.uniforms.u_positions.value = gpuCompute.getCurrentRenderTarget(positionVariable).texture;
            }

            if (!handsLeftRightDefined && hand1.children.length > 0 && hand2.children.length > 0) {
                getHandLeftRight();
            }

            if (handsLeftRightDefined) {
                setObjectToHand();
                const leftHandIndexTip = leftHand.joints['index-finger-tip'];
                if (leftHandIndexTip) {
                    leftHandIndexTip.getWorldPosition(leftHandInteractionPosition);
                    positionVariable.material.uniforms.u_interaction_point.value.copy(leftHandInteractionPosition);
                } else {
                    positionVariable.material.uniforms.u_interaction_point.value.set(1000, 1000, 1000);
                }
            } else if (positionVariable) {
                positionVariable.material.uniforms.u_interaction_point.value.set(1000, 1000, 1000);
            }

            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
